<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Voice Bot</title>
  </head>
  <body>
    <h2>Voice-to-Voice Bot</h2>
    <button id="start">Start</button>
    <button id="stop" disabled>Stop</button>
    <div>
      <strong>Partial Transcript:</strong> <span id="partial"></span>
    </div>
    <div>
      <strong>Final Transcript:</strong>
      <ul id="history"></ul>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.1/socket.io.min.js"></script>
    <script>
      const socket = io();

      const startBtn = document.getElementById("start");
      const stopBtn = document.getElementById("stop");
      const partialSpan = document.getElementById("partial");
      const historyList = document.getElementById("history");

      let mediaRecorder;
      let audioContext;
      let processor;
      let source;
      let sendInterval;
      let leftchannel = [];
      let recordingLength = 0;
      let sampleRate = 16000;

      socket.on("connect", () => {
        console.log("connected to server");
      });

      socket.on("transcript", (data) => {
        if (data.partial) {
          partialSpan.textContent = data.text;
        } else {
          // final
          partialSpan.textContent = "";
          const li = document.createElement("li");
          li.textContent = "User: " + data.text;
          historyList.appendChild(li);
        }
      });

      socket.on("bot_audio", (data) => {
        // Play base64 wav
        const audio_b64 = data.audio_b64;
        const text = data.text;
        const audio_blob = base64ToBlob(audio_b64, "audio/wav");
        const url = URL.createObjectURL(audio_blob);
        const au = new Audio(url);
        au.play();
        const li = document.createElement("li");
        li.textContent = "Bot: " + text;
        historyList.appendChild(li);
      });

      function base64ToBlob(b64Data, contentType='application/octet-stream', sliceSize=512) {
        const byteCharacters = atob(b64Data);
        const byteArrays = [];
        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
          const slice = byteCharacters.slice(offset, offset + sliceSize);
          const byteNumbers = new Array(slice.length);
          for (let i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          byteArrays.push(byteArray);
        }
        return new Blob(byteArrays, {type: contentType});
      }

      // We'll record with AudioContext at 48k (typical), convert to 16k PCM16 mono
      async function startRecording() {
        startBtn.disabled = true;
        stopBtn.disabled = false;
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        source = audioContext.createMediaStreamSource(stream);
        const bufferSize = 4096;
        processor = audioContext.createScriptProcessor(bufferSize, 1, 1);

        source.connect(processor);
        processor.connect(audioContext.destination);

        processor.onaudioprocess = function(e) {
          const float32Array = e.inputBuffer.getChannelData(0);
          // convert float32 [-1,1] to 16-bit PCM at 16k
          const downsampled = downsampleBuffer(float32Array, audioContext.sampleRate, sampleRate);
          const pcmEncoded = encodeWAV(downsampled, sampleRate);
          // send chunk as base64
          const reader = new FileReader();
          const blob = new Blob([pcmEncoded], {type: 'audio/wav'});
          reader.onload = function() {
            const b64 = reader.result.split(',')[1];
            socket.emit('audio_chunk', { chunk: b64, final: false });
          };
          reader.readAsDataURL(blob);
        };
      }

      function stopRecording() {
        startBtn.disabled = false;
        stopBtn.disabled = true;
        if (processor) {
          processor.disconnect();
          source.disconnect();
          audioContext.close();
          socket.emit('audio_chunk', { chunk: null, final: true });
        }
      }

      startBtn.onclick = startRecording;
      stopBtn.onclick = stopRecording;

      // Helpers: downsample and encode WAV
      function downsampleBuffer(buffer, origSampleRate, targetRate) {
        if (targetRate === origSampleRate) {
          return buffer;
        }
        const sampleRateRatio = origSampleRate / targetRate;
        const newLength = Math.round(buffer.length / sampleRateRatio);
        const result = new Float32Array(newLength);
        let offsetResult = 0;
        let offsetBuffer = 0;
        while (offsetResult < result.length) {
          const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
          let accum = 0, count = 0;
          for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
            accum += buffer[i];
            count++;
          }
          result[offsetResult] = accum / count;
          offsetResult++;
          offsetBuffer = nextOffsetBuffer;
        }
        return result;
      }

      function encodeWAV(samples, sampleRate) {
        const buffer = new ArrayBuffer(44 + samples.length * 2);
        const view = new DataView(buffer);
        /* RIFF identifier */
        writeString(view, 0, 'RIFF');
        /* file length */
        view.setUint32(4, 36 + samples.length * 2, true);
        /* RIFF type */
        writeString(view, 8, 'WAVE');
        /* format chunk identifier */
        writeString(view, 12, 'fmt ');
        /* format chunk length */
        view.setUint32(16, 16, true);
        /* sample format (raw) */
        view.setUint16(20, 1, true);
        /* channel count */
        view.setUint16(22, 1, true);
        /* sample rate */
        view.setUint32(24, sampleRate, true);
        /* byte rate (sampleRate * blockAlign) */
        view.setUint32(28, sampleRate * 2, true);
        /* block align (channel count * bytes per sample) */
        view.setUint16(32, 2, true);
        /* bits per sample */
        view.setUint16(34, 16, true);
        /* data chunk identifier */
        writeString(view, 36, 'data');
        /* data chunk length */
        view.setUint32(40, samples.length * 2, true);
        // write PCM samples
        floatTo16BitPCM(view, 44, samples);
        return view;
      }

      function floatTo16BitPCM(output, offset, input) {
        for (let i = 0; i < input.length; i++, offset += 2) {
          let s = Math.max(-1, Math.min(1, input[i]));
          s = s < 0 ? s * 0x8000 : s * 0x7fff;
          output.setInt16(offset, s, true);
        }
      }

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }
    </script>
  </body>
</html>
